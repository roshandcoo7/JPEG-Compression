# -*- coding: utf-8 -*-
"""JPEG_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h_0zOoJoJFs8ye-ASmsWVvBxg-FzRm1_

# **In this version, I will not do huffman coding, Instead, I will use the huffman coding table available in the JPEG documentation**

READ THE IMAGE
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import numpy as np 
import pandas as pd 
import math
import cv2
from matplotlib import pyplot as plt
import matplotlib.pylab as pylab

# %pprint
# %matplotlib inline
pylab.rcParams['figure.figsize'] = (20.0, 7.0)

img = cv2.imread('/content/drive/My Drive/DSP/MARBLES.BMP',cv2.IMREAD_GRAYSCALE)

plt.figure(figsize=(10,10))
plt.imshow(img,cmap='gray')

height = img.shape[0]
width = img.shape[1]

print('height=',height )
print('width=',width )

height = int(math.ceil(height/8)*8)
width  = int(math.ceil(width/8)*8)

print('height=',height )
print('width=',width )

img = cv2.resize(img,(width,height,))
img.shape

plt.figure(figsize=(10,10))
plt.imshow(img,cmap='gray')

"""FUNCTION FOR DCT"""

def dct2(a):
    return scipy.fftpack.dct( scipy.fftpack.dct( a, axis=0, norm='ortho' ), axis=1, norm='ortho' )

def idct2(a):
    return scipy.fftpack.idct( scipy.fftpack.idct( a, axis=0 , norm='ortho'), axis=1 , norm='ortho')

"""PERFORM DCT"""

import numpy as np
import matplotlib.pyplot as plt
import scipy

from numpy import pi
from numpy import sin
from numpy import zeros
from numpy import r_
from scipy import signal
from scipy import misc # pip install Pillow
import matplotlib.pylab as pylab

imsize = img.shape
dct = np.zeros(imsize)

# Do 8x8 DCT on image (in-place)
for i in r_[:imsize[0]:8]:
    for j in r_[:imsize[1]:8]:
        dct[i:(i+8),j:(j+8)] = dct2( img[i:(i+8),j:(j+8)] )

pos = 128
# Extract a block from image
plt.figure()
plt.imshow(img[pos:pos+8,pos:pos+8],cmap='gray')
plt.title( "An 8x8 Image block")

# Display the dct of that block
plt.figure()
plt.imshow(dct[pos:pos+8,pos:pos+8],cmap='gray',vmax= np.max(dct)*0.01,vmin = 0, extent=[0,pi,pi,0])
plt.title( "An 8x8 DCT block")

plt.figure()
plt.imshow(dct,cmap='gray',vmax = np.max(dct)*0.01,vmin = 0)
plt.title( "8x8 DCTs of the image")

"""QUANTIZATION MATRIX"""

def QMatrix(q):


  Q = np.array([[16,11,10,16,24,40,51,61],
              [12,12,14,19,26,58,60,55],
              [14,13,16,24,40,57,69,56],
              [14,17,22,29,51,87,80,62],
              [18,22,37,56,68,109,103,77],
              [24,35,55,64,81,104,113,92],
              [49,64,78,87,103,121,120,101],
              [72,92,95,98,112,100,130,99]])
  Q_new = np.empty([8,8])

  if q<50:
    S = 5000/q
  else:
    S = 200 - 2*q

  for i in range(8):
    for j in range(8):
      Q_new[i][j] = math.floor((S*Q[i][j]+50)/100)
      if Q_new[i][j] > 255:
        Q_new[i][j] = 255

  return Q_new

quality = int(input('CHOOSE QUALITY FROM 10,50, AND 90'))
Q = QMatrix(quality)

temp = np.concatenate((Q,Q))
for i in range((height//8)-2):
  temp = np.concatenate((temp,Q))
temp_2 = np.concatenate((temp,temp),axis=1)
for i in range((width//8)-2):
  temp_2 = np.concatenate((temp_2,temp),axis=1)
Q = temp_2

Q.shape

quantized = np.round(np.divide(dct,Q))

plt.figure()
plt.imshow(quantized,cmap='gray',vmax = np.max(quantized)*0.01,vmin = 0)
plt.title( "QUANTIZED image")

"""SLICING THE ARRAY"""

sliced = np.empty([height,width])

def blockshaped(arr, nrows, ncols):
    h, w = arr.shape
    assert h % nrows == 0, "{} rows is not evenly divisble by {}".format(h, nrows)
    assert w % ncols == 0, "{} cols is not evenly divisble by {}".format(w, ncols)
    return (arr.reshape(h//nrows, nrows, -1, ncols)
               .swapaxes(1,2)
               .reshape(-1, nrows, ncols))

sliced = blockshaped(quantized,int(height/126),int(width/178))
sliced = sliced.reshape(126,178,8,8).astype(int)
sliced[10][45]

"""ZIG ZAG SCANNING"""

def zigzagger(matrix):
  rows = 8
  columns = 8
  solution=[[] for i in range(rows+columns-1)] 
  
  for i in range(rows): 
      for j in range(columns): 
          sum=i+j 
          if(sum%2 ==0):    
              #add at beginning 
              solution[sum].insert(0,matrix[i][j]) 
          else:     
              #add at end of the list 
              solution[sum].append(matrix[i][j]) 
            
  final = list()           
  # print the solution as it as 
  for i in solution: 
      for j in i: 
          final.append(j)
  return final

vector = list()

for i in range(126):
  for j in range(178):
    a = zigzagger(sliced[i][j])
    vector.append(a)
vector = np.asarray(vector)

"""ENTROPY CODING

> DPCM on DC Components
"""

def DPCM(data):
  l = len(data)
  for i in range(l-1,0,-1):
    data[i][0] = data[i][0] - data[i-1][0]
  return data
vector = DPCM(vector)

""">DC COMPONENT SIZE -> HUFFMAN TABLE"""

DC_size = dict({0:'00',1:'010',2:'011',3:'100',4:'101',5:'110',6:'1110',7:'11110',8:'111110',9:'1111110',10:'11111110',11:'111111110'})

"""> AC COMPONENT HUFFMAN TABLE"""



"""> VALUE -> HUFFMAN"""

global value

def tostr(s): 
    new = "" 
    for x in s: 
        new += x   
    return new 

def value_huff(num):
  if num > 0:
    value = bin(num)[2:]
  elif num < 0:
    value = list(bin(abs(num)))
    value = value[2:]
    for i in range(len(value)):
      if value[i] == '0':
        value[i] = '1'
      elif value[i] == '1': 
        value[i] = '0'
  code =  tostr(value)
  size = DC_size[len(code)]
  return (size,code)

""">RLE on AC Components"""

from itertools import chain, groupby

def rle_ac(iterable):
  final = list()
  x =  list(chain.from_iterable((len([*thing]),val) for val, thing in groupby(iterable)))
  for i in range(0,len(x),2):
    if x[i+1] != 0:
      final.extend([x[i+1]]*x[i])
    else:
      final.append(x[i])
      final.append(0)

  final[len(final)-1] = (0,0)
  final.pop(len(final)-2)

  temp = final
  
  for i in range(1,len(temp)):
    if temp[i] == 0:
      rl = final[i-1]
      s = len(bin(final[i+1]))-2
      val = final[i+1]
      final[i] = ((rl,s),val)
  temp = final

  for i in range(1,len(temp)):
    if type(temp[i]) == 'int':
      rl = 0
      s = len(bin(final[i]))-2
      val = final[i]
      final[i] = ((rl,s),val)
  print(final)

a = [2,3,5,0,0,0,0,1,0,0,0,0,0]
rle_ac(a)

a = [2,3,5,0,0,0,0,1,0,0,0,0,0]
rle_ac(a)

n_coded = list()
for i in range(len(vector)):
  n_coded.append(rle_ac(vector[i]))

"""HUFFMAN on DC"""

def tostr(s): 
    new = "" 
    for x in s: 
        new += x   
    return new 

def value_huff(num):
  if num > 0:
    value = bin(num)[2:]
  elif num < 0:
    value = list(bin(abs(num)))
    value = value[2:]
    for i in range(len(value)):
      if value[i] == '0':
        value[i] = '1'
      elif value[i] == '1': 
        value[i] = '0'
  code =  tostr(value)
  size = DC_codes[len(code)]
  return (size,code)